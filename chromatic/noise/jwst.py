#!/usr/bin/env python
from ..imports import *
import json


# Details of PandExo files are [here](https://natashabatalha.github.io/PandExo/jwstdict.html?highlight=rawdata).

extraction_box = 3


def extract_sn_from_image(images):
    """
    Use a 2D image to estimate per-wavelength S/N.

    (This is tuned for MIRI/LRS. It probably won't work on anything else.)

    Returns
    -------
    sn_extracted : array
        The 1D extracted S/N.
    """

    # extract S/N and saturation images
    sn = images["snr"]
    saturation = images["saturation"]

    # define extraction aperture
    y_pix = np.arange(sn.shape[0]) - sn.shape[0] / 2 + 0.5
    extent = [0, sn.shape[1] - 1, -sn.shape[0] / 2 + 0.5, sn.shape[0] / 2 + 0.5]
    extract = np.abs(y_pix) < extraction_box
    extract_alpha = 0.5
    print(f"{np.sum(extract)} pixels being used in the extraction")

    # display the images
    fi, ax = plt.subplots(
        2,
        2,
        figsize=(7.5, 3),
        gridspec_kw=dict(width_ratios=[8, 1]),
        sharey="row",
        sharex="col",
    )

    plt.sca(ax[0, 0])
    plt.imshow(np.log10(sn), extent=extent, cmap="gray")

    sat_color = "red"
    sat_cmap = one2another(bottom=sat_color, top=sat_color, alpha_bottom=0, alpha_top=1)
    plt.imshow(saturation, extent=extent, cmap=sat_cmap, vmax=2)
    for sign in [-1, 1]:
        plt.axhline(sign * extraction_box, alpha=extract_alpha, color="gray")

    plt.sca(ax[0, 1])
    spatial_profile = np.nanmean(sn, axis=1)
    plt.plot(spatial_profile, y_pix, color="black")
    for sign in [-1, 1]:
        plt.axhline(sign * extraction_box, alpha=extract_alpha, color="gray")

    sn_extracted = np.sqrt(np.sum(sn**2, axis=0))
    plt.sca(ax[1, 0])
    plt.plot(sn_extracted, color="black")
    plt.ylabel("S/N per pixel\nper integration")

    for i, label in zip([1, 2], ["partial", "full"]):
        is_saturated = np.nonzero(np.max(saturation, axis=0) >= i)[0]
        if len(is_saturated) > 0:
            left, right = np.min(is_saturated), np.max(is_saturated)
            plt.axvspan(
                left,
                right,
                color=sat_color,
                alpha=0.25 * i,
            )
        print(f"{len(is_saturated)} pixels experience at least {label} saturation")
    return sn_extracted


def set_image_slice(instrument):
    if instrument.lower() == "p750l":
        image_slice = slice(27, 399)
    else:
        image_slice = slice(None)
    return image_slice


def read_pandexo(
    filename="pandexo/MIRI-LRS-500K-5groups/ETC-calculationbe8855c0-2602-43ed-aa67-fb12d1eede69e.p",
):
    """
    Read a PandExo output file, including S/N estimates.

    Parameters
    ----------
    filename : str
        The filepath to a `.p` pickle file generated by Pandexo.

    Returns
    -------
    table : array
        1D extracted results
    images : array
        2D image results
    """

    # read the pickle file
    f = open(filename, "rb")
    d = pickle.load(f)

    # get the overall pandexo depth and uncertainty results
    s = d["FinalSpectrum"]
    spectra = {}
    spectra["pixel_number"] = np.arange(len(s["wave"]))
    spectra["wavelength"] = s["wave"]
    spectra["planet_model"] = s["spectrum"]
    spectra["planet_realization"] = s["spectrum_w_rand"]
    spectra["depth_uncertainty"] = s["error_w_floor"]

    # get some metadata about the timing.
    t = d["timing"]
    metadata = {}

    metadata["input"] = d["input"]
    metadata["transit_duration"] = t["Transit Duration"]
    metadata["observation_duration"] = t["Transit+Baseline, no overhead (hrs)"]
    metadata["cadence"] = t["Time/Integration incl reset (sec)"]
    metadata["observing_efficiency"] = 0.01 * t["Observing Efficiency (%)"]
    metadata["number_of_groups_per_integration"] = t["APT: Num Groups per Integration"]
    metadata["number_of_integrations_per_transit"] = t["Num Integrations In Transit"]

    # make sure that the number of transits is 1
    assert t["Number of Transits"] == 1

    # get some warnings.
    w = d["PandeiaOutTrans"]["warnings"]
    for k in w:
        if "saturated" in k:
            metadata[k] = w[k]

    # get the raw pandeia results. (Details [here](https://jwst-docs.stsci.edu/jwst-exposure-time-calculator-overview/jwst-etc-outputs-overview/jwst-etc-downloads)).
    pandeia_results = d["PandeiaOutTrans"]["1d"]
    pandeia_results.keys()

    for k in pandeia_results:
        if len(pandeia_results[k]) == 2:
            this_wave = pandeia_results[k][0]
            assert np.all(this_wave == spectra["wavelength"])
            N_w = len(this_wave)
            N_y = len(pandeia_results[k][1])
            if N_y == N_w:
                spectra[k] = pandeia_results[k][1]
            else:
                print(f"skipping {k} because its size {N_y} exceeds {N_w} wavelengths")

    t_integration = metadata["cadence"] * metadata["observing_efficiency"]
    n_integrations = metadata["number_of_integrations_per_transit"]

    signal = spectra["extracted_flux"] * t_integration * n_integrations
    noise = np.sqrt(
        (spectra["extracted_flux"] + spectra["extracted_bg_only"])
        * t_integration
        * n_integrations
    )
    reconstructed_estimate = noise / signal * np.sqrt(2)
    spectra["depth_uncertainty_estimate_from_etc"] = reconstructed_estimate

    t = Table(spectra, meta=metadata)

    """plt.plot(t["wavelength"], spectra["depth_uncertainty"], label="pandexo")
    plt.plot(
        spectra["wavelength"],
        spectra["depth_uncertainty_estimate_from_etc"],
        label="ETC-reconstructed",
    )
    plt.yscale("log")
    plt.legend()
    plt.show()"""

    # get some images
    images = {}
    image_slice = set_image_slice(d["input"]["Disperser"])
    for k in ["detector", "snr", "saturation"]:
        images[k] = d["PandeiaOutTrans"]["2d"][k][:, image_slice]
        """plt.imshow(images[k])
        plt.title(k)
        plt.show()"""
    images["snr"] /= np.sqrt(metadata["number_of_integrations_per_transit"])

    t["sn_extracted_from_image"] = extract_sn_from_image(images)
    t["sn_scaled_from_depth"] = 1 / (
        t["depth_uncertainty"]
        * np.sqrt(metadata["number_of_integrations_per_transit"])
        / np.sqrt(2)
    )
    plt.plot(t["sn_scaled_from_depth"], label="scaled from PandExo depth")

    return t, images


def read_etc(directory, t_int=0.64):
    """
    Read the outputs of the JWST ETC into a table and some images.

    Returns
    -------
    table : array
        1D extracted results
    images : array
        2D image results

    """

    # find all the FITS files in the directory
    fits_filenames = glob.glob(os.path.join(directory, "*/*.fits"))
    input_filename = os.path.join(directory, "input.json")

    # load the metadata inputs
    with open(input_filename) as f:
        inputs = json.load(f)

    arrays = {}
    images = {}
    image_slice = set_image_slice(inputs["configuration"]["instrument"]["disperser"])

    for f in fits_filenames:

        if "lineplot" in f:
            k = os.path.basename(f).split(".fits")[0].replace("lineplot_", "")
            if k == "total_flux":
                continue
            if "wave" in k:
                arrays[k] = fits.open(f)[1].data["wavelength"]
            else:
                arrays[k] = fits.open(f)[1].data[k]
        if "image" in f:
            k = os.path.basename(f).split(".fits")[0].replace("image_", "")
            images[k] = fits.open(f)[0].data[:, image_slice]

    signal = arrays["extracted_flux"] * t_int
    noise = np.sqrt((arrays["extracted_flux"] + arrays["extracted_bg_total"]) * t_int)
    arrays["snr_estimated_from_just_photons"] = signal / noise
    metadata = {}
    metadata["input"] = inputs
    metadata["t_int"] = t_int

    t = Table(arrays, meta=metadata)

    t["sn_extracted_from_image"] = extract_sn_from_image(images)
    plt.plot(t["sn"], label="S/N direct from ETC")

    return t, images


def compare_etc_and_pandexo(t_etc, t_pandexo):
    """
    Compare S/N estimates between the official ETC and Pandexo.

    Parameters
    ----------
    t_etc : Table
        The 1D tabular output from `read_etc`
    t_pandexo : Table
        The 1D tabular output from `read_pandexo`
    """
    plt.plot(t_etc["wave_pix"], t_etc["sn"], label="ETC, S/N")
    plt.plot(
        t_etc["wave_pix"],
        t_etc["snr_estimated_from_just_photons"],
        label="ETC, S/N from photons",
    )
    plt.plot(
        t_etc["wave_pix"], t_etc["sn_extracted_from_image"], label="ETC, S/N from image"
    )

    plt.plot(t_pandexo["wavelength"], t_pandexo["sn"], label="pandexo, S/N")
    plt.plot(
        t_pandexo["wavelength"],
        t_pandexo["sn_scaled_from_depth"],
        label="pandexo, S/N from depth",
    )
    plt.plot(
        t_pandexo["wavelength"],
        t_pandexo["sn_extracted_from_image"],
        label="pandexo, S/N from image",
    )

    plt.xlabel("Wavelength (microns)")
    plt.ylabel("S/N per extracted pixel (?!?) per integration")
    plt.legend(frameon=False)
